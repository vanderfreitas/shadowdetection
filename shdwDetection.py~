#!/usr/bin/python
# -*- coding: UTF-8 -*-

import cv2
import numpy as np
from matplotlib import pyplot as plt
import math
from scipy.signal import argrelextrema
import scipy.ndimage.filters as ft
import scipy.signal as sg

from matplotlib.widgets import Slider, Button, RadioButtons


from suavizar import *



# Normalizacao do mapa de sombras para [0,255]
def map2img(value, menor, diff):
	return (np.uint8) (((value - menor) * 255.0) / diff )



def shadowDetection(imgIn):
	# Le imagem de entrada
	#nomeImgEntrada = 'ori/DSC_0559.jpg'
	#imgIn = cv2.imread(nomeImgEntrada)
	lin = imgIn.shape[0]
	col = imgIn.shape[1]


	# Mapa de sombras com zeros
	size = (lin, col, 1)
	shdwMap = np.zeros((lin,col), dtype=float)

	# Matiz
	matiz = np.zeros((lin,col), dtype=float)


	
	# Estatisticas da imagem
	maiorShdwMap = 0.0
	menorShdwMap = 255.0


	# Filtro bilateral para suavizacao da imagem de entrada (mascara de tamanho 3)	
	w = 7
	imgFiltered = cv2.bilateralFilter(imgIn, w, 700, 25) 



	# Calcula o mapa de sombras dentro do Loop
	# Conversao RGB -> HSI
	# Calcula indice de sombras
	for l in xrange(lin):
		for c in xrange(col):
			R = imgFiltered.item(l,c,2)
			G = imgFiltered.item(l,c,1)
			B = imgFiltered.item(l,c,0)


			# Calculo das componentes S e I do sistema HSI - valores entre 0 e 255
			I  = (0.33333333) * (R + G + B);

			V1 = (-0.40824829 * (R + G)) + (0.816496581 * B);
			V2 = (0.40824829 * R) -(0.816496581 * G);

			S = math.sqrt(V1*V1 + V2*V2);


			# Range [0,1] para as componentes I e S;
			I /= 255.0;
			S /= 255.0;


			# Calculo do Indice quantificador de sombras
			shdwMap[l,c] = I - S


			numerador = 0.5 * ( (R-G) + (R-B) )
			denominador = math.sqrt( (R-G)**2 + (R-B)*(G-B) )

			if denominador != 0:
				theta = math.acos(numerador/denominador)
			else:
				theta = 360


			H = 0
			if B <= G:
				H = math.degrees(theta)
			else:
				H = 360.0 - math.degrees(theta)

			matiz[l,c] = H
			
			



	# Calcula estatisticas da imagem
	menorShdwMap = np.min(shdwMap)
	maiorShdwMap = np.max(shdwMap)
	difference = maiorShdwMap - menorShdwMap

	#print "media do mapa: ", map2img(np.average(shdwMap), menorShdwMap, difference)
	#print "std mapa: ", map2img(np.std(shdwMap), menorShdwMap, difference)
	#print "menor: ", map2img(menorShdwMap, menorShdwMap, difference), "  maior: ", map2img(maiorShdwMap, menorShdwMap, difference)



	# Mapa de sombras com zeros
	size = (lin, col, 1)
	shdwMapNorm = np.zeros((lin,col), dtype=np.uint8)

	# Normalizar mapa de sombras
	for l in xrange(lin):
		for c in xrange(col):
			value = shdwMap[l,c]
			shdwMapNorm[l,c] = (np.uint8) (((value - menorShdwMap) * 255.0) / difference )
		


	
	# Matriz de co-ocorrencia
	size = (256, 256, 1)
	mCoOcorrencia = np.zeros(size, dtype=long)

	# Calculo da matriz de co-ocorrencia
	for l in xrange(0,lin-1):
		for c in xrange(0,col-1):
			# Direita
			iCol = shdwMapNorm[l,c]
			jRow = shdwMapNorm[l,c+1]

			mCoOcorrencia[jRow,iCol,0] += 1

			# baixo
			iCol = shdwMapNorm[l,c]
			jRow = shdwMapNorm[l+1,c]

			mCoOcorrencia[jRow,iCol,0] += 1


	# Atribui apenas os valores da dagonal principal da matriz de co-ocorrencia
	histogramaDiagPrinc = np.zeros(256, dtype=float)
	for l in xrange(256):
		histogramaDiagPrinc[l] = mCoOcorrencia[l,l,0]


	# Suaviza os valores da diagonal principal da matriz de co-ocorrencia
	histogramaDiagPrinc = smooth(histogramaDiagPrinc, window_len=11)


	soma = np.sum(histogramaDiagPrinc)
	#print "soma total: ", soma
	corte = float(soma) * 0.01  # 1 porcento
	#print "2 perc: ", corte

	#print histogramaDiagPrinc


	inicio = 0
	s = 0
	#print "\nCALCULO DO INICIO"
	for i in xrange(len(histogramaDiagPrinc)):
		s += histogramaDiagPrinc[i]
		#print "valor: ", histogramaDiagPrinc[i], "  acum: ", s
		if s > corte:
			inicio = i-1
			break

	fim = 0
	s = 0


	corte = float(soma) * 0.5  # metade dos pixels
	#print "\nCALCULO DO FIM"
	for i in xrange(len(histogramaDiagPrinc)-1, 1, -1):
		s += histogramaDiagPrinc[i]
		#print "valor: ", histogramaDiagPrinc[i], "  acum: ", s
		if s > corte:
			fim = i
			break

	#print "\n"
	if inicio < 0:
		inicio = 0

	if fim >= len(histogramaDiagPrinc):
		fim = len(histogramaDiagPrinc) - 1

	print "inicio: ", inicio, "  fim: ", fim



	# Calcula os minimos locais dessa diagonal
	#minLocais = argrelextrema(histogramaDiagPrinc, np.less)
	minLocais = argrelextrema(histogramaDiagPrinc, np.less)
	print "minimos locais: ", minLocais


	# Considera thresholds candidatos como sendo aqueles menores que 255/2
	thresholds = [th for th in minLocais[0] if th > inicio and th < (255/2+1)]


	print thresholds

	if len(thresholds) == 0:
		threshold = -1
	else:
		threshold = np.mean(thresholds)
	print "THRESHOLD: ", threshold


	# Imagem de saida com zeros
	size = (lin, col, 1)
	imgOut = cv2.cvtColor(imgIn, cv2.COLOR_BGR2GRAY)
	imgOut[:] = 0

	for l in xrange(lin):
		for c in xrange(col):
			if shdwMapNorm[l,c] < threshold and (matiz[l,c] > 130 and matiz[l,c] < 300):   #AERIAL
			#if shdwMapNorm[l,c] < threshold and (matiz[l,c] > 110 and matiz[l,c] < 300):   #AERIAL
			#if shdwMapNorm[l,c] < threshold and (matiz[l,c] < 60 or matiz[l,c] > 150):   #TERRESTRIAL
				imgOut[l,c] = 255


	# Resultados TERRESTRES 355 IMAGENS
	# Sem filtrar a matiz: # P/R/F =  0.755640825892 / 0.419777310769 / 0.47532431066
	# (matiz[l,c] < 60 or matiz[l,c] > 110)  # P/R/F =  0.599172253086 / 0.456333222169 / 0.45507945029
	# (matiz[l,c] < 90 or matiz[l,c] > 120)  # P/R/F =  0.708713021936 / 0.41794308723 / 0.463930522127
	# (matiz[l,c] < 100 or matiz[l,c] > 140) # P/R/F =  0.721138815103 / 0.420956700359 / 0.469039573535


	# Resultados TERRESTRES 281 IMAGENS
	# Sem filtrar a matiz: P/R/F =  0.664480168863 / 0.406976010973 / 0.416476056791
	# (matiz[l,c] < 100 or matiz[l,c] > 140)  # P/R/F =  0.631656237255 / 0.405433127471 / 0.407409379897
	# (matiz[l,c] > 110 and matiz[l,c] < 300) # P/R/F =  0.400450866769 / 0.551673412329 / 0.373748733041
	# (matiz[l,c] < 60 or matiz[l,c] > 150)   # P/R/F =  0.487660467803 / 0.480444825317 / 0.421067212301



	'''# Operacao morfologica de fechamento na imagem de saida (dilatacao e erosao, nessa ordem)
	# dim eh o tamanho do filtro
	if lin < 200:
		dim = 3
	elif lin < 500:
		dim = 5
	elif lin < 1000:
		dim = 7
	else:
		dim = 9
	print "dim: ", dim

	strElem = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(dim,dim)) # elemento estruturante eh um circulo
	imgOut = cv2.morphologyEx(imgOut, cv2.MORPH_CLOSE, strElem)'''

	return imgOut



def shadowDetection_KH(imgIn):

	lin = imgIn.shape[0]
	col = imgIn.shape[1]


	# Mapa de sombras com zeros
	size = (lin, col, 1)
	shdwMap = np.zeros((lin,col), dtype=float)

	# Matiz
	matiz = np.zeros((lin,col), dtype=float)


	# Estatisticas da imagem
	maiorShdwMap = 0.0
	menorShdwMap = 255.0


	# Filtro bilateral para suavizacao da imagem de entrada (mascara de tamanho 7)	
	w = 7
	imgFiltered = cv2.bilateralFilter(imgIn, w, 700, 25) 



	# Calcula o mapa de sombras dentro do Loop
	# Conversao RGB -> HSI
	# Calcula indice de sombras
	for l in xrange(lin):
		for c in xrange(col):
			R = imgFiltered.item(l,c,2)
			G = imgFiltered.item(l,c,1)
			B = imgFiltered.item(l,c,0)


			# Calculo das componentes S e I do sistema HSI - valores entre 0 e 255
			I  = (0.33333333) * (R + G + B);

			V1 = (-0.40824829 * (R + G)) + (0.816496581 * B);
			V2 = (0.40824829 * R) -(0.816496581 * G);

			S = math.sqrt(V1*V1 + V2*V2);


			# Range [0,1] para as componentes I e S;
			I /= 255.0;
			S /= 255.0;


			# Calculo do Indice quantificador de sombras
			shdwMap[l,c] = I - S


			# Calculo da Matiz
			numerador = 0.5 * ( (R-G) + (R-B) )
			denominador = math.sqrt( (R-G)**2 + (R-B)*(G-B) )

			if denominador != 0:
				theta = math.acos(numerador/denominador)
			else:
				theta = 360


			H = 0
			if B <= G:
				H = math.degrees(theta)
			else:
				H = 360.0 - math.degrees(theta)

			matiz[l,c] = H



	# Calcula estatisticas da imagem
	menorShdwMap = np.min(shdwMap)
	maiorShdwMap = np.max(shdwMap)
	difference = maiorShdwMap - menorShdwMap


	# Normalizar mapa de sombras para o intervalo [0,255]
	for l in xrange(lin):
		for c in xrange(col):
			value = shdwMap[l,c]
			shdwMap[l,c] = (np.uint8) (((value - menorShdwMap) * 255.0) / difference )
		

	# Matriz de co-ocorrencia
	size = (256, 256, 1)
	mCoOcorrencia = np.zeros(size, dtype=long)

	# Calculo da matriz de co-ocorrencia
	for l in xrange(0,lin-1):
		for c in xrange(0,col-1):
			# Direita
			iCol = shdwMap[l,c]
			jRow = shdwMap[l,c+1]

			mCoOcorrencia[jRow,iCol,0] += 1

			# baixo
			iCol = shdwMap[l,c]
			jRow = shdwMap[l+1,c]

			mCoOcorrencia[jRow,iCol,0] += 1


	# Valores da diagonal principal da matriz de co-ocorrencia
	histogramaDiagPrinc = np.zeros(256, dtype=float)
	for l in xrange(256):
		histogramaDiagPrinc[l] = mCoOcorrencia[l,l,0]


	# Suaviza os valores da diagonal principal da matriz de co-ocorrencia (janela de tam 11)
	histogramaDiagPrinc = smooth(histogramaDiagPrinc, window_len=11)


	# Remove os primeiros 2 percent dos valores desse histograma, e tbm os ultimos 2 percent
	#print histogramaDiagPrinc
	soma = np.sum(histogramaDiagPrinc)
	#print "soma total: ", soma
	corte = float(soma) * 0.01  # 1 porcento
	#print "2 perc: ", corte


	inicio = 0
	s = 0
	#print "\nCALCULO DO INICIO"
	for i in xrange(len(histogramaDiagPrinc)):
		s += histogramaDiagPrinc[i]
		#print "valor: ", histogramaDiagPrinc[i], "  acum: ", s
		if s > corte:
			inicio = i-1
			break

	fim = 0
	s = 0

	corte = float(soma) * 0.5  # metade dos pixels
	#print "\nCALCULO DO FIM"
	for i in xrange(len(histogramaDiagPrinc)-1, 1, -1):
		s += histogramaDiagPrinc[i]
		#print "valor: ", histogramaDiagPrinc[i], "  acum: ", s
		if s > corte:
			fim = i+1
			break

	#print "\n"
	if inicio < 0:
		inicio = 0

	if fim >= len(histogramaDiagPrinc):
		fim = len(histogramaDiagPrinc) - 1

	print "inicio: ", inicio, "  fim: ", fim


	# Calcula os minimos locais dessa diagonal
	#minLocais = argrelextrema(histogramaDiagPrinc, np.less)
	minLocais = argrelextrema(histogramaDiagPrinc, np.less)
	print "minimos locais: ", minLocais


	# Considera thresholds candidatos como sendo aqueles menores que 255/2
	if fim > (255/2+1):	
		limSup = fim
	else:
		limSup = (255/2+1)
	thresholds = [th for th in minLocais[0] if th > inicio and th < limSup]


	print thresholds

	if len(thresholds) == 0:
		threshold = -1
	else:
		threshold = np.mean(thresholds)
	print "THRESHOLD: ", threshold


	# Imagem de saida com zeros
	size = (lin, col, 1)
	imgOut = cv2.cvtColor(imgIn, cv2.COLOR_BGR2GRAY)
	imgOut[:] = 0


	R_medio_nonShdw = 0.0
	G_medio_nonShdw = 0.0
	B_medio_nonShdw = 0.0
	count = 0.0


	for l in xrange(lin):
		for c in xrange(col):
			# Candidatas a sombras (valor 255) sao valores abaixo do threshold
			if shdwMap[l,c] > threshold:

				# Calcula os valores de R,G,B medio da imagem 
				# original, apenas nas areas sem sombras
				if shdwMap[l,c] > fim:
					R_medio_nonShdw += imgIn.item(l,c,2)
					G_medio_nonShdw += imgIn.item(l,c,1)
					B_medio_nonShdw += imgIn.item(l,c,0)
					count += 1.0
			else:
				imgOut[l,c] = 255

	# imgOut2 eh uma copia da imgOut
	imgOut2 = np.copy(imgOut)

	# Caso existam pixels livres de sombra na imagem
	#print "COUNT: ", count
	if count > 0:
		R_medio_nonShdw = R_medio_nonShdw / count
		G_medio_nonShdw = G_medio_nonShdw / count
		B_medio_nonShdw = B_medio_nonShdw / count

		K_R = 0.0
		K_G = 0.0
		K_B = 0.0

		# Varrer as areas livres de sombra, verificando a propriedade dos K_H, com janelas de dimensao 3
		for l in xrange(1,lin-1):
			for c in xrange(1,col-1):
				# Caso o pixel em questao NAO seja de sombra
				#if imgOut[l,c] == 0:
					
				R_med = 0.0
				G_med = 0.0
				B_med = 0.0

				# Para que o processo de verificacao de sombra seja aplicado, 
				# Todos os pixels da janela abaixo devem pertencer 
				# ao mesmo alvo
				allSameTarget = True
				target = imgOut[l,c]
				for ll in xrange(-1,2):
					for cc in xrange(-1,2):
						if imgOut[l+ll, c+cc] != target:
							allSameTarget = False
						else:
							B_med += imgIn[l+ll, c+cc, 0]
							G_med += imgIn[l+ll, c+cc, 1]
							R_med += imgIn[l+ll, c+cc, 2]

				

				# VERIFICAR OS K_H
				# CASO SEJAM TODOS DO MESMO ALVO
				if allSameTarget == True:
					# Calcula os componentes K_H
					R_med = R_med / 9.0
					G_med = G_med / 9.0
					B_med = B_med / 9.0

					K_R=((R_medio_nonShdw+14)**2.4) / ((R_med+14)**2.4)
					K_G=((G_medio_nonShdw+14)**2.4) / ((G_med+14)**2.4)
					K_B=((B_medio_nonShdw+14)**2.4) / ((B_med+14)**2.4)

					# Caso o valor corresponda a uma sombra, entao
					# ele eh rotulado como sombra
					if isSombra(K_R, K_G, K_B) == True:	
						imgOut2[l,c] = 255
					else:
						imgOut2[l,c] = 0			
					


	'''# Operacao morfologica de fechamento na imagem de saida (dilatacao e erosao, nessa ordem)
	# dim eh o tamanho do filtro
	if lin < 200:
		dim = 3
	elif lin < 500:
		dim = 5
	elif lin < 1000:
		dim = 7
	else:
		dim = 9
	print "dim: ", dim

	strElem = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(dim,dim)) # elemento estruturante eh um circulo
	imgOut = cv2.morphologyEx(imgOut2, cv2.MORPH_OPEN, strElem)'''


	return imgOut2




def shadowDetection_Polidorio(imgIn, tipo):
	# tipo:
	# 0: satelite - threshold = -0.2
	# 1: aerial - threshold = 0

	if tipo == 0:
		threshold = -0.2
	else:	
		threshold = 0


	lin = imgIn.shape[0]
	col = imgIn.shape[1]


	# Imagem de saida com zeros
	size = (lin, col, 1)
	imgOut = cv2.cvtColor(imgIn, cv2.COLOR_BGR2GRAY)
	imgOut[:] = 0


	# Calcula o mapa de sombras dentro do Loop
	# Conversao RGB -> HSI
	# Calcula indice de sombras
	for l in xrange(lin):
		for c in xrange(col):
			R = imgIn.item(l,c,2)
			G = imgIn.item(l,c,1)
			B = imgIn.item(l,c,0)


			# Calculo das componentes S e I do sistema HSI - valores entre 0 e 255
			I  = (0.33333333) * (R + G + B);

			V1 = (-0.40824829 * (R + G)) + (0.816496581 * B);
			V2 = (0.40824829 * R) -(0.816496581 * G);

			S = math.sqrt(V1*V1 + V2*V2);


			# Range [0,1] para as componentes I e S;
			I /= 255.0;
			S /= 255.0;



			numerador = 0.5 * ( (R-G) + (R-B) )
			denominador = math.sqrt( (R-G)**2 + (R-B)*(G-B) )

			if denominador != 0:
				theta = math.acos(numerador/denominador)
			else:
				theta = 360


			H = 0
			if B <= G:
				H = math.degrees(theta)
			else:
				H = 360.0 - math.degrees(theta)


			# Calculo do Indice quantificador de sombras
			ind = I - S
			
			
			#print "H: ", H
			#if ind < threshold:
			if (H>200 and H<320):
				imgOut[l,c] = 255

	return imgOut



def shadowDetection_Santos(imgIn):

	lin = imgIn.shape[0]
	col = imgIn.shape[1]

        mask = np.zeros((3,3), dtype=np.int8)

    	mask[0,0] = -1;
    	mask[0,1] = -1;
    	mask[0,2] = -1;
    	mask[1,0] = -1;
    	mask[1,1] = 32;
    	mask[1,2] = -1;
    	mask[2,0] = -1;
    	mask[2,1] = -1;
    	mask[2,2] = -1;



	imgOut = np.zeros((lin, col), dtype=np.uint8)

	shadowMatrix = np.full((lin, col), 0, dtype=float)

	gray = cv2.cvtColor(imgIn, cv2.COLOR_BGR2GRAY)

	#w = 7
	#gray = cv2.bilateralFilter(gray, w, 700, 25) 
	shadowMatrix = sg.convolve(gray,mask) / 8.0

	
	for l in xrange(lin):
		for c in xrange(col):
			'''R = imgIn.item(l,c,2)
			G = imgIn.item(l,c,1)
			B = imgIn.item(l,c,0)

			numerador = 0.5 * ( (R-G) + (R-B) )
			denominador = math.sqrt( (R-G)**2 + (R-B)*(G-B) )

			if denominador != 0:
				theta = math.acos(numerador/denominador)
			else:
				theta = 360

			H = 0
			if B <= G:
				H = math.degrees(theta)
			else:
				H = 360.0 - math.degrees(theta)'''
		

			if shadowMatrix[l,c] <= 255:
				imgOut[l,c] = 255




	# Terrestrial  355
	# Sem filtrar           # P/R/F =  0.771599252979 / 0.421908596248 / 0.470847060943
	# (H < 100 or H > 140)  # P/R/F =  0.737804455675 / 0.422446528823 / 0.464189667227
	# (H > 110 and H < 300) # P/R/F =  0.463077914243 / 0.570584440309 / 0.424590784912


	# Terrestrial  281  (sem aereas)
	# (H < 100 or H > 140)  # P/R/F =  0.693971236964 / 0.473366543785 / 0.485145662924

    	
	return imgOut



'''def shadowDetection_Santos_KH(imgIn):

	lin = imgIn.shape[0]
	col = imgIn.shape[1]

        mask = np.zeros((3,3), dtype=np.int8)

    	mask[0,0] = -1;
    	mask[0,1] = -1;
    	mask[0,2] = -1;
    	mask[1,0] = -1;
    	mask[1,1] = 32;
    	mask[1,2] = -1;
    	mask[2,0] = -1;
    	mask[2,1] = -1;
    	mask[2,2] = -1;



	imgOut = np.zeros((lin, col), dtype=np.uint8)

	shadowMatrix = np.full((lin, col), 0, dtype=float)

	gray = cv2.cvtColor(imgIn, cv2.COLOR_BGR2GRAY)

	w = 7
	gray = cv2.bilateralFilter(gray, w, 700, 25) 
	shadowMatrix = ft.convolve(gray,mask) / 8.0
			
		

			

	R_medio_nonShdw = 0.0
	G_medio_nonShdw = 0.0
	B_medio_nonShdw = 0.0
	count = 0.0
	for l in xrange(lin):
		for c in xrange(col):
			# Candidatas a sombras (valor 255) sao valores abaixo do threshold
			if shadowMatrix[l,c] > 255:
				
				# Calcula os valores de R,G,B medio da imagem 
				# original, apenas nas areas sem sombras
				if gray[l,c] > 255/2:
					R_medio_nonShdw += imgIn.item(l,c,2)
					G_medio_nonShdw += imgIn.item(l,c,1)
					B_medio_nonShdw += imgIn.item(l,c,0)
					count += 1.0
			else:
				imgOut[l,c] = 255


	# imgOut2 eh uma copia da imgOut
	imgOut2 = np.copy(imgOut)

	# Caso existam pixels livres de sombra na imagem
	#print "COUNT: ", count
	if count > 0:
		R_medio_nonShdw = R_medio_nonShdw / count
		G_medio_nonShdw = G_medio_nonShdw / count
		B_medio_nonShdw = B_medio_nonShdw / count

		K_R = 0.0
		K_G = 0.0
		K_B = 0.0

		# Varrer as areas livres de sombra, verificando a propriedade dos K_H, com janelas de dimensao 3
		for l in xrange(1,lin-1):
			for c in xrange(1,col-1):
				# Caso o pixel em questao NAO seja de sombra
				#if imgOut[l,c] == 0:
					
				R_med = 0.0
				G_med = 0.0
				B_med = 0.0

				# Para que o processo de verificacao de sombra seja aplicado, 
				# Todos os pixels da janela abaixo devem pertencer 
				# ao mesmo alvo
				allSameTarget = True
				target = imgOut[l,c]
				for ll in xrange(-1,2):
					for cc in xrange(-1,2):
						if imgOut[l+ll, c+cc] != target:
							allSameTarget = False
						else:
							B_med += imgIn[l+ll, c+cc, 0]
							G_med += imgIn[l+ll, c+cc, 1]
							R_med += imgIn[l+ll, c+cc, 2]

				

				# VERIFICAR OS K_H
				# CASO SEJAM TODOS DO MESMO ALVO
				if allSameTarget == True:
					# Calcula os componentes K_H
					R_med = R_med / 9.0
					G_med = G_med / 9.0
					B_med = B_med / 9.0

					K_R=((R_medio_nonShdw+14)**2.4) / ((R_med+14)**2.4)
					K_G=((G_medio_nonShdw+14)**2.4) / ((G_med+14)**2.4)
					K_B=((B_medio_nonShdw+14)**2.4) / ((B_med+14)**2.4)

					# Caso o valor corresponda a uma sombra, entao
					# ele eh rotulado como sombra
					if isSombra(K_R, K_G, K_B) == True:	
						imgOut2[l,c] = 255
					else:
						imgOut2[l,c] = 0


	strElem = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(11,11)) # elemento estruturante eh um circulo
	imgOut2 = cv2.morphologyEx(imgOut2, cv2.MORPH_OPEN, strElem)

	# usando K_H e morfologia: P/R/F =  0.844388748744 / 0.460758349707 / 0.537009675389


	# Terrestrial  355
	# Sem filtrar           # P/R/F =  0.771599252979 / 0.421908596248 / 0.470847060943
	# (H < 100 or H > 140)  # P/R/F =  0.737804455675 / 0.422446528823 / 0.464189667227
	# (H > 110 and H < 300) # P/R/F =  0.463077914243 / 0.570584440309 / 0.424590784912


	# Terrestrial  281  (sem aereas)
	# (H < 100 or H > 140)  # P/R/F =  0.693971236964 / 0.473366543785 / 0.485145662924

    	
	return imgOut2'''






def isSombra(K_R, K_G, K_B):

	# Property 1: tal*K_H^80 < K_H < eta*K_H^20
	if K_R < 1.59 or K_R > 48.44:
		return False

	if K_G < 1.43 or K_G > 41.6:
		return False

	if K_B < 1.27 or K_B > 32.4:
		return False

	# Property 2   K_R > K_G > K_B
	if (K_B>K_R) or (K_B>K_G) or (K_G>K_R):
   		return False

	# Property 3   
	# K_R-K_G>epsilon and K_G-K_B>epsilon  if  K_R>K_R^80
	# K_R-K_G> (epsilon/2) and K_G-K_B>(epsilon/2)  if  K_R<=K_R^80
	# epsilon = 0.33/2 = 0.165

	if K_R>3.18:
		if (K_R-K_G)<0.165 or (K_G-K_B)<0.165:
			return False
	
	elif (K_R-K_G)<0.0825 or (K_G-K_B)<0.0825:
		return False

	return True


def isSombraTIAN(K_R, K_G, K_B, ori_R, ori_G, ori_B, shdw_R, shdw_G, shdw_B):

	if K_B>K_R or K_B>K_G or (K_G>K_R):
		return False

	if K_B<1.4:
		return False

	if ori_B<shdw_B or ori_G<shdw_G or ori_R<shdw_R:
		return False

	cha=np.min([ori_R-shdw_R, ori_G-shdw_G, ori_B-shdw_B])
	if cha<20:
		return False

	cha=np.max([shdw_R, shdw_G, shdw_B]);
	if cha>170:
		return False

	if K_R>3:
		if (K_R-K_G)<0.1 or (K_G-K_B)<0.1 or (K_R-K_B)<0.2:
			return False

		elif (K_R-K_G)<0.05 or (K_G-K_B)<0.05 or (K_R-K_B)<0.1:
			return False

	return True


def shadowDetection_Santos_KH(imgIn):

	lin = imgIn.shape[0]
	col = imgIn.shape[1]

        mask = np.zeros((3,3), dtype=float)

    	mask[0,0] = -1.0;
    	mask[0,1] = -1.0;
    	mask[0,2] = -1.0;
    	mask[1,0] = -1.0;
    	mask[1,1] = 32.0;
    	mask[1,2] = -1.0;
    	mask[2,0] = -1.0;
    	mask[2,1] = -1.0;
    	mask[2,2] = -1.0;


	imgOut = np.zeros((lin, col), dtype=np.uint8)
	shadowMatrix = np.full((lin, col), 0, dtype=float)
	#gray = cv2.cvtColor(imgIn, cv2.COLOR_BGR2GRAY)
	I_band = np.zeros((lin, col), dtype=np.uint8)
	#shdwMap = np.zeros((lin,col), dtype=np.uint8)

	np.zeros((lin, col), dtype=np.uint8)

	for l in xrange(lin):
		for c in xrange(col):
			R = imgIn.item(l,c,2)
			G = imgIn.item(l,c,1)
			B = imgIn.item(l,c,0)


			# Calculo das componentes S e I do sistema HSI - valores entre 0 e 255
			I  = (0.33333333) * (R + G + B);
			
			I_band[l,c] = I

	#print I_band
	
	w = 7
	gray = cv2.bilateralFilter(I_band, w, 700, 25) 
	shadowMatrix = sg.convolve(gray,mask)/8.0

	threshold = np.mean(gray)
	
	R_medio_nonShdw = 0.0
	G_medio_nonShdw = 0.0
	B_medio_nonShdw = 0.0
	count = 0.0
	for l in xrange(2,lin-2):
		for c in xrange(2,col-2):
			# Candidatas a sombras (valor 255) sao valores abaixo do threshold
			if shadowMatrix[l,c] > threshold*1.3:
				
				# Calcula os valores de R,G,B medio da imagem 
				# original, apenas nas areas sem sombras
				if gray[l,c] > 255/2:
					R_medio_nonShdw += imgIn.item(l,c,2)
					G_medio_nonShdw += imgIn.item(l,c,1)
					B_medio_nonShdw += imgIn.item(l,c,0)
					count += 1.0
			else:
				imgOut[l,c] = 255

	# imgOut2 eh uma copia da imgOut
	imgOut2 = np.copy(imgOut)
	
	# Caso existam pixels livres de sombra na imagem
	#print "COUNT: ", count
	if count > 0:
		R_medio_nonShdw = R_medio_nonShdw / count
		G_medio_nonShdw = G_medio_nonShdw / count
		B_medio_nonShdw = B_medio_nonShdw / count

		K_R = 0.0
		K_G = 0.0
		K_B = 0.0

		# Varrer as areas livres de sombra, verificando a propriedade dos K_H, com janelas de dimensao 3
		for l in xrange(2,lin-2):
			for c in xrange(2,col-2):
					
				R_med = 0.0
				G_med = 0.0
				B_med = 0.0

				# Para que o processo de verificacao de sombra seja aplicado, 
				# Todos os pixels da janela abaixo devem pertencer 
				# ao mesmo alvo
				allSameTarget = True
				target = imgOut[l,c]
				for ll in xrange(-1,2):
					for cc in xrange(-1,2):
						if imgOut[l+ll, c+cc] != target:
							allSameTarget = False
						else:
							B_med += imgIn[l+ll, c+cc, 0]
							G_med += imgIn[l+ll, c+cc, 1]
							R_med += imgIn[l+ll, c+cc, 2]

				
				# VERIFICAR OS K_H
				# CASO SEJAM TODOS DO MESMO ALVO
				if allSameTarget == True:
					# Calcula os componentes K_H
					R_med = R_med / 9.0
					G_med = G_med / 9.0
					B_med = B_med / 9.0

					K_R=((R_medio_nonShdw+14)**2.4) / ((R_med+14)**2.4)
					K_G=((G_medio_nonShdw+14)**2.4) / ((G_med+14)**2.4)
					K_B=((B_medio_nonShdw+14)**2.4) / ((B_med+14)**2.4)

					# Caso o valor corresponda a uma sombra, entao
					# ele eh rotulado como sombra
					if isSombra(K_R, K_G, K_B) == True:
						imgOut2[l,c] = 255
					


	strElem = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(3,3)) # elemento estruturante eh um circulo
	imgOut2 = cv2.morphologyEx(imgOut2, cv2.MORPH_CLOSE, strElem)

	return imgOut2

		

